// A type-level specification that some enum variants are not possible.
// - This will be a lot easier with refinement types.
// - Related RFC: https://github.com/rust-lang/rfcs/issues/754

use crate::*;

//==================================================================================================
// An example enum with per-variant specifications.
// - Wish: This could be done automatically and implicitly for all enums.

trait ESpec {
    type ECaseA;
    type ECaseB;
}

enum E<T: ESpec> {
    A(i32, T::ECaseA),
    B(T::ECaseB),
}

//==================================================================================================
// Example: Empty specification
// Wish: This could be auto-generated by default and implicit.

struct Any {}

impl ESpec for Any {
    type ECaseA = True; // Can be anything but False.
    type ECaseB = True; // Can be anything but False.
}

fn e_any(e: E<Any>) -> Option<i32> {
    match e {
        E::A(data, _) => Some(data),
        E::B(_) => None,
    }
}

//==================================================================================================
// Example specification: E, but only A variant is possible.

struct OnlyA {}

impl ESpec for OnlyA {
    type ECaseA = True; // Can be anything but False.
    type ECaseB = False;
}

// Note: This function is infallible.
fn e_only_a(e: E<OnlyA>) -> i32 {
    match e {
        E::A(data, _) => data,

        // Wish: Can we make `infeasible!` with no arguments?
        //       (automatic detection of False in context)
        // Wish: Even better if the compiler allows us to drop the E::B variant case.
        E::B(hypothesis) => infeasible!(hypothesis),
    }
}

fn test() {
    e_any(E::A(42, Default::default()));
    e_any(E::B(Default::default()));

    e_only_a(E::A(42, Default::default()));
    // e_only_a(E::B(Default::default())); // error

    // Wish: implicit type-level argument
    // - We'd like trivially true type-level arguments to be elided automatically.
    // - So, we can write as below:
    //   e_only_a(E::A(42)); // not allowed at this time.
}
